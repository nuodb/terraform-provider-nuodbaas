// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.0 DO NOT EDIT.
package openapi

import (
	"encoding/json"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes  = "basicAuth.Scopes"
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for BackupStatusModelState.
const (
	BackupStatusModelStateDeleting  BackupStatusModelState = "Deleting"
	BackupStatusModelStateFailed    BackupStatusModelState = "Failed"
	BackupStatusModelStatePending   BackupStatusModelState = "Pending"
	BackupStatusModelStateSucceeded BackupStatusModelState = "Succeeded"
)

// Defines values for BackupStatusModelRetainedAs.
const (
	BackupStatusModelRetainedAsDaily   BackupStatusModelRetainedAs = "daily"
	BackupStatusModelRetainedAsHourly  BackupStatusModelRetainedAs = "hourly"
	BackupStatusModelRetainedAsMonthly BackupStatusModelRetainedAs = "monthly"
	BackupStatusModelRetainedAsWeekly  BackupStatusModelRetainedAs = "weekly"
	BackupStatusModelRetainedAsYearly  BackupStatusModelRetainedAs = "yearly"
)

// Defines values for DatabaseStatusModelState.
const (
	DatabaseStatusModelStateAvailable            DatabaseStatusModelState = "Available"
	DatabaseStatusModelStateCreating             DatabaseStatusModelState = "Creating"
	DatabaseStatusModelStateDeleting             DatabaseStatusModelState = "Deleting"
	DatabaseStatusModelStateExpired              DatabaseStatusModelState = "Expired"
	DatabaseStatusModelStateFailed               DatabaseStatusModelState = "Failed"
	DatabaseStatusModelStateModifying            DatabaseStatusModelState = "Modifying"
	DatabaseStatusModelStateRestoring            DatabaseStatusModelState = "Restoring"
	DatabaseStatusModelStateRotatingCertificates DatabaseStatusModelState = "RotatingCertificates"
	DatabaseStatusModelStateStopped              DatabaseStatusModelState = "Stopped"
	DatabaseStatusModelStateStopping             DatabaseStatusModelState = "Stopping"
)

// Defines values for ErrorContentCode.
const (
	ErrorContentCodeCONCURRENTUPDATE ErrorContentCode = "CONCURRENT_UPDATE"
	ErrorContentCodeHTTPERROR        ErrorContentCode = "HTTP_ERROR"
	ErrorContentCodeUNKNOWNREQUEST   ErrorContentCode = "UNKNOWN_REQUEST"
)

// Defines values for JsonPatchOperationOp.
const (
	JsonPatchOperationOpAdd     JsonPatchOperationOp = "add"
	JsonPatchOperationOpCopy    JsonPatchOperationOp = "copy"
	JsonPatchOperationOpMove    JsonPatchOperationOp = "move"
	JsonPatchOperationOpRemove  JsonPatchOperationOp = "remove"
	JsonPatchOperationOpReplace JsonPatchOperationOp = "replace"
	JsonPatchOperationOpTest    JsonPatchOperationOp = "test"
)

// Defines values for ProjectStatusModelState.
const (
	ProjectStatusModelStateAvailable            ProjectStatusModelState = "Available"
	ProjectStatusModelStateCreating             ProjectStatusModelState = "Creating"
	ProjectStatusModelStateDeleting             ProjectStatusModelState = "Deleting"
	ProjectStatusModelStateExpired              ProjectStatusModelState = "Expired"
	ProjectStatusModelStateFailed               ProjectStatusModelState = "Failed"
	ProjectStatusModelStateModifying            ProjectStatusModelState = "Modifying"
	ProjectStatusModelStateRotatingCertificates ProjectStatusModelState = "RotatingCertificates"
	ProjectStatusModelStateStopped              ProjectStatusModelState = "Stopped"
	ProjectStatusModelStateStopping             ProjectStatusModelState = "Stopping"
)

// Defines values for RotationSettingsModelDayOfWeek.
const (
	RotationSettingsModelDayOfWeekFriday    RotationSettingsModelDayOfWeek = "Friday"
	RotationSettingsModelDayOfWeekMonday    RotationSettingsModelDayOfWeek = "Monday"
	RotationSettingsModelDayOfWeekSaturday  RotationSettingsModelDayOfWeek = "Saturday"
	RotationSettingsModelDayOfWeekSunday    RotationSettingsModelDayOfWeek = "Sunday"
	RotationSettingsModelDayOfWeekThursday  RotationSettingsModelDayOfWeek = "Thursday"
	RotationSettingsModelDayOfWeekTuesday   RotationSettingsModelDayOfWeek = "Tuesday"
	RotationSettingsModelDayOfWeekWednesday RotationSettingsModelDayOfWeek = "Wednesday"
)

// Defines values for RotationSettingsModelMonth.
const (
	RotationSettingsModelMonthApril     RotationSettingsModelMonth = "April"
	RotationSettingsModelMonthAugust    RotationSettingsModelMonth = "August"
	RotationSettingsModelMonthDecember  RotationSettingsModelMonth = "December"
	RotationSettingsModelMonthFebruary  RotationSettingsModelMonth = "February"
	RotationSettingsModelMonthJanuary   RotationSettingsModelMonth = "January"
	RotationSettingsModelMonthJuly      RotationSettingsModelMonth = "July"
	RotationSettingsModelMonthJune      RotationSettingsModelMonth = "June"
	RotationSettingsModelMonthMarch     RotationSettingsModelMonth = "March"
	RotationSettingsModelMonthMay       RotationSettingsModelMonth = "May"
	RotationSettingsModelMonthNovember  RotationSettingsModelMonth = "November"
	RotationSettingsModelMonthOctober   RotationSettingsModelMonth = "October"
	RotationSettingsModelMonthSeptember RotationSettingsModelMonth = "September"
)

// BackupCreateModel defines model for BackupCreateModel.
type BackupCreateModel struct {
	// Organization The organization that the backup belongs to
	Organization string `cty:"organization" hcl:"organization" json:"organization" tfsdk:"organization"`

	// Project The project that the backup belongs to
	Project string `cty:"project" hcl:"project" json:"project" tfsdk:"project"`

	// Database The database that the backup belongs to
	Database string `cty:"database" hcl:"database" json:"database" tfsdk:"database"`

	// Labels User-defined labels attached to the resource that can be used for filtering
	Labels *map[string]string `cty:"labels" hcl:"labels" json:"labels,omitempty" tfsdk:"labels"`
}

// BackupModel defines model for BackupModel.
type BackupModel struct {
	// Organization The organization that the backup belongs to
	Organization string `cty:"organization" hcl:"organization" json:"organization" tfsdk:"organization"`

	// Project The project that the backup belongs to
	Project string `cty:"project" hcl:"project" json:"project" tfsdk:"project"`

	// Database The database that the backup belongs to
	Database string `cty:"database" hcl:"database" json:"database" tfsdk:"database"`

	// Name The name of the backup
	Name string `cty:"name" hcl:"name" json:"name" tfsdk:"name"`

	// Labels User-defined labels attached to the resource that can be used for filtering
	Labels *map[string]string `cty:"labels" hcl:"labels" json:"labels,omitempty" tfsdk:"labels"`

	// ResourceVersion The version of the resource. When specified in a `PUT` request payload, indicates that the resoure should be updated, and is used by the system to guard against concurrent updates.
	ResourceVersion *string            `json:"resourceVersion,omitempty" tfsdk:"-"`
	ImportSource    *ImportSourceModel `cty:"import_source" hcl:"import_source" json:"importSource,omitempty" tfsdk:"import_source"`
	Status          *BackupStatusModel `cty:"status" hcl:"status" json:"status,omitempty" tfsdk:"status"`
}

// BackupPolicyMissedBackup defines model for BackupPolicyMissedBackup.
type BackupPolicyMissedBackup struct {
	// MissedTime The time that a backup was missed by this policy
	MissedTime *string `cty:"missed_time" hcl:"missed_time" json:"missedTime,omitempty" tfsdk:"missed_time"`

	// Database The fully-qualified database name for which a backup was missed by this policy
	Database *string `cty:"database" hcl:"database" json:"database,omitempty" tfsdk:"database"`

	// Reason A programmatic identifier indicating the reason for missing a backup by this policy
	Reason *string `cty:"reason" hcl:"reason" json:"reason,omitempty" tfsdk:"reason"`

	// Message A human readable message indicating details about the missed backup by this policy
	Message *string `cty:"message" hcl:"message" json:"message,omitempty" tfsdk:"message"`
}

// BackupPolicyModel defines model for BackupPolicyModel.
type BackupPolicyModel struct {
	// Organization The organization that the backup policy belongs to
	Organization string `cty:"organization" hcl:"organization" json:"organization" tfsdk:"organization"`

	// Name The name of the backup policy
	Name string `cty:"name" hcl:"name" json:"name" tfsdk:"name"`

	// Labels User-defined labels attached to the resource that can be used for filtering
	Labels *map[string]string `cty:"labels" hcl:"labels" json:"labels,omitempty" tfsdk:"labels"`

	// Frequency The frequency to schedule backups at, in cron format
	Frequency string `cty:"frequency" hcl:"frequency" json:"frequency" tfsdk:"frequency"`

	// Suspended Whether backups from the policy are suspended
	Suspended *bool `cty:"suspended" hcl:"suspended" json:"suspended,omitempty" tfsdk:"suspended"`

	// ResourceVersion The version of the resource. When specified in a `PUT` request payload, indicates that the resoure should be updated, and is used by the system to guard against concurrent updates.
	ResourceVersion *string                      `json:"resourceVersion,omitempty" tfsdk:"-"`
	Properties      *BackupPolicyPropertiesModel `cty:"properties" hcl:"properties" json:"properties,omitempty" tfsdk:"properties"`
	Retention       *RetentionModel              `cty:"retention" hcl:"retention" json:"retention,omitempty" tfsdk:"retention"`
	Selector        SelectorModel                `cty:"selector" hcl:"selector" json:"selector" tfsdk:"selector"`
	Status          *BackupPolicyStatusModel     `cty:"status" hcl:"status" json:"status,omitempty" tfsdk:"status"`
}

// BackupPolicyPropertiesModel defines model for BackupPolicyPropertiesModel.
type BackupPolicyPropertiesModel struct {
	// PropagatePolicyLabels Whether to propagate the user-defined labels from the backup policy to backup resources created by this policy
	PropagatePolicyLabels *bool `cty:"propagate_policy_labels" hcl:"propagate_policy_labels" json:"propagatePolicyLabels,omitempty" tfsdk:"propagate_policy_labels"`

	// PropagateDatabaseLabels Whether to propagate the user-defined labels from the matching database to backup resources created by this policy
	PropagateDatabaseLabels *bool `cty:"propagate_database_labels" hcl:"propagate_database_labels" json:"propagateDatabaseLabels,omitempty" tfsdk:"propagate_database_labels"`
}

// BackupPolicyStatusModel defines model for BackupPolicyStatusModel.
type BackupPolicyStatusModel struct {
	// LastScheduleTime The time that backups were last taken by this policy
	LastScheduleTime *string `cty:"last_schedule_time" hcl:"last_schedule_time" json:"lastScheduleTime,omitempty" tfsdk:"last_schedule_time"`

	// LastMissedScheduleTime The time that backups were last missed by this policy
	LastMissedScheduleTime *string `cty:"last_missed_schedule_time" hcl:"last_missed_schedule_time" json:"lastMissedScheduleTime,omitempty" tfsdk:"last_missed_schedule_time"`

	// NextScheduleTime The time that backups are next scheduled by this policy
	NextScheduleTime *string `cty:"next_schedule_time" hcl:"next_schedule_time" json:"nextScheduleTime,omitempty" tfsdk:"next_schedule_time"`

	// LastMissedBackups The last database backups that were not scheduled by this policy
	LastMissedBackups *[]BackupPolicyMissedBackup `cty:"last_missed_backups" hcl:"last_missed_backups" json:"lastMissedBackups,omitempty" tfsdk:"last_missed_backups"`
}

// BackupStatusModel defines model for BackupStatusModel.
type BackupStatusModel struct {
	// CreationTime The time that the backup was taken
	CreationTime *string `cty:"creation_time" hcl:"creation_time" json:"creationTime,omitempty" tfsdk:"creation_time"`

	// BackupHandle The handle for the backup
	BackupHandle *string `cty:"backup_handle" hcl:"backup_handle" json:"backupHandle,omitempty" tfsdk:"backup_handle"`

	// BackupPlugin The plugin used to manage the backup
	BackupPlugin *string `cty:"backup_plugin" hcl:"backup_plugin" json:"backupPlugin,omitempty" tfsdk:"backup_plugin"`

	// ReadyToUse Whether the backup is ready to be used to restore a database
	ReadyToUse *bool `cty:"ready_to_use" hcl:"ready_to_use" json:"readyToUse,omitempty" tfsdk:"ready_to_use"`

	// Message Message summarizing the state of the backup
	Message *string `cty:"message" hcl:"message" json:"message,omitempty" tfsdk:"message"`

	// State The state of the backup:
	//   * `Pending` - The backup is pending completion
	//   * `Succeeded` - The backup completed successfully and is available for use
	//   * `Failed` - The backup failed and is unusable
	//   * `Deleting` - The backup has been marked for deletion, which is in progress
	State *BackupStatusModelState `cty:"state" hcl:"state" json:"state,omitempty" tfsdk:"state"`

	// CreatedByPolicy The fully-qualified name of the backup policy that the backup was created by
	CreatedByPolicy *string `cty:"created_by_policy" hcl:"created_by_policy" json:"createdByPolicy,omitempty" tfsdk:"created_by_policy"`

	// RetainedAs The matching retention cycles by this backup
	RetainedAs *[]BackupStatusModelRetainedAs `cty:"retained_as" hcl:"retained_as" json:"retainedAs,omitempty" tfsdk:"retained_as"`

	// DatabaseProductVersion The product version of the database that the backup belongs to
	DatabaseProductVersion *string `cty:"database_product_version" hcl:"database_product_version" json:"databaseProductVersion,omitempty" tfsdk:"database_product_version"`
}

// BackupStatusModelState The state of the backup:
//   - `Pending` - The backup is pending completion
//   - `Succeeded` - The backup completed successfully and is available for use
//   - `Failed` - The backup failed and is unusable
//   - `Deleting` - The backup has been marked for deletion, which is in progress
type BackupStatusModelState string

// BackupStatusModelRetainedAs defines model for BackupStatusModel.RetainedAs.
type BackupStatusModelRetainedAs string

// DatabaseCreateUpdateModel defines model for DatabaseCreateUpdateModel.
type DatabaseCreateUpdateModel struct {
	// Organization The organization that the database belongs to
	Organization string `cty:"organization" hcl:"organization" json:"organization" tfsdk:"organization"`

	// Project The project that the database belongs to
	Project string `cty:"project" hcl:"project" json:"project" tfsdk:"project"`

	// Name The name of the database
	Name string `cty:"name" hcl:"name" json:"name" tfsdk:"name"`

	// Labels User-defined labels attached to the resource that can be used for filtering
	Labels *map[string]string `cty:"labels" hcl:"labels" json:"labels,omitempty" tfsdk:"labels"`

	// DbaPassword The password for the DBA user. Can only be specified when creating a database.
	DbaPassword *string `cty:"dba_password" hcl:"dba_password" json:"dbaPassword,omitempty" tfsdk:"dba_password"`

	// Tier The service tier for the database. If omitted, the project service tier is inherited.
	Tier *string `cty:"tier" hcl:"tier" json:"tier,omitempty" tfsdk:"tier"`

	// ResourceVersion The version of the resource. When specified in a `PUT` request payload, indicates that the resoure should be updated, and is used by the system to guard against concurrent updates.
	ResourceVersion *string                  `json:"resourceVersion,omitempty" tfsdk:"-"`
	Maintenance     *MaintenanceModel        `cty:"maintenance" hcl:"maintenance" json:"maintenance,omitempty" tfsdk:"maintenance"`
	Properties      *DatabasePropertiesModel `cty:"properties" hcl:"properties" json:"properties,omitempty" tfsdk:"properties"`
	RestoreFrom     *RestoreFromModel        `cty:"restore_from" hcl:"restore_from" json:"restoreFrom,omitempty" tfsdk:"restore_from"`
	Status          *DatabaseStatusModel     `cty:"status" hcl:"status" json:"status,omitempty" tfsdk:"status"`
}

// DatabaseModel defines model for DatabaseModel.
type DatabaseModel struct {
	// Organization The organization that the database belongs to
	Organization string `cty:"organization" hcl:"organization" json:"organization" tfsdk:"organization"`

	// Project The project that the database belongs to
	Project string `cty:"project" hcl:"project" json:"project" tfsdk:"project"`

	// Name The name of the database
	Name string `cty:"name" hcl:"name" json:"name" tfsdk:"name"`

	// Labels User-defined labels attached to the resource that can be used for filtering
	Labels *map[string]string `cty:"labels" hcl:"labels" json:"labels,omitempty" tfsdk:"labels"`

	// Tier The service tier for the database. If omitted, the project service tier is inherited.
	Tier *string `cty:"tier" hcl:"tier" json:"tier,omitempty" tfsdk:"tier"`

	// ResourceVersion The version of the resource. When specified in a `PUT` request payload, indicates that the resoure should be updated, and is used by the system to guard against concurrent updates.
	ResourceVersion *string                  `json:"resourceVersion,omitempty" tfsdk:"-"`
	Maintenance     *MaintenanceModel        `cty:"maintenance" hcl:"maintenance" json:"maintenance,omitempty" tfsdk:"maintenance"`
	Properties      *DatabasePropertiesModel `cty:"properties" hcl:"properties" json:"properties,omitempty" tfsdk:"properties"`
	RestoreFrom     *RestoreFromModel        `cty:"restore_from" hcl:"restore_from" json:"restoreFrom,omitempty" tfsdk:"restore_from"`
	Status          *DatabaseStatusModel     `cty:"status" hcl:"status" json:"status,omitempty" tfsdk:"status"`
}

// DatabasePropertiesModel defines model for DatabasePropertiesModel.
type DatabasePropertiesModel struct {
	// ArchiveDiskSize The size of the archive volumes for the database. Can be only updated to increase the volume size.
	ArchiveDiskSize *string `cty:"archive_disk_size" hcl:"archive_disk_size" json:"archiveDiskSize,omitempty" tfsdk:"archive_disk_size"`

	// JournalDiskSize The size of the journal volumes for the database. Can be only updated to increase the volume size.
	JournalDiskSize *string `cty:"journal_disk_size" hcl:"journal_disk_size" json:"journalDiskSize,omitempty" tfsdk:"journal_disk_size"`

	// TierParameters Opaque parameters supplied to database service tier.
	TierParameters *map[string]string `cty:"tier_parameters" hcl:"tier_parameters" json:"tierParameters,omitempty" tfsdk:"tier_parameters"`

	// InheritTierParameters Whether to inherit tier parameters from the project if the database service tier matches the project.
	InheritTierParameters *bool `json:"inheritTierParameters,omitempty" tfsdk:"-"`

	// ProductVersion The version/tag of the NuoDB image to use. For available tags, see https://hub.docker.com/r/nuodb/nuodb/tags. If omitted, the database version will be inherited from the project.
	ProductVersion *string `cty:"product_version" hcl:"product_version" json:"productVersion,omitempty" tfsdk:"product_version"`
}

// DatabaseStatusModel defines model for DatabaseStatusModel.
type DatabaseStatusModel struct {
	// SqlEndpoint The endpoint for SQL clients to connect to
	SqlEndpoint *string `cty:"sql_endpoint" hcl:"sql_endpoint" json:"sqlEndpoint,omitempty" tfsdk:"sql_endpoint"`

	// CaPem The PEM-encoded certificate for SQL clients to verify database servers
	CaPem *string `cty:"ca_pem" hcl:"ca_pem" json:"caPem,omitempty" tfsdk:"ca_pem"`

	// Ready Whether the database is ready
	Ready *bool `cty:"ready" hcl:"ready" json:"ready,omitempty" tfsdk:"ready"`

	// Shutdown Whether the database has shutdown
	Shutdown *bool `cty:"shutdown" hcl:"shutdown" json:"shutdown,omitempty" tfsdk:"shutdown"`

	// Message Message summarizing the state of the database
	Message *string `cty:"message" hcl:"message" json:"message,omitempty" tfsdk:"message"`

	// State The state of the database:
	//   * `Available` - The database is ready to accept SQL connections
	//   * `Creating` - The database is being created and not yet available
	//   * `Modifying` - The database is being modified
	//   * `Stopping` - Shutdown is in progress for this database
	//   * `Stopped` - The database has been stopped
	//   * `Expired` - The database has expired
	//   * `Failed` - The database has failed to achieve a usable state
	//   * `Deleting` - The database has been marked for deletion, which is in progress
	//   * `Restoring` - Restore from backup is in progress for this database
	//   * `RotatingCertificates` - TLS certificates rotation is in progress for this database
	State *DatabaseStatusModelState `cty:"state" hcl:"state" json:"state,omitempty" tfsdk:"state"`
}

// DatabaseStatusModelState The state of the database:
//   - `Available` - The database is ready to accept SQL connections
//   - `Creating` - The database is being created and not yet available
//   - `Modifying` - The database is being modified
//   - `Stopping` - Shutdown is in progress for this database
//   - `Stopped` - The database has been stopped
//   - `Expired` - The database has expired
//   - `Failed` - The database has failed to achieve a usable state
//   - `Deleting` - The database has been marked for deletion, which is in progress
//   - `Restoring` - Restore from backup is in progress for this database
//   - `RotatingCertificates` - TLS certificates rotation is in progress for this database
type DatabaseStatusModelState string

// ErrorContent defines model for ErrorContent.
type ErrorContent struct {
	// Code Application-level error code that describes how the error should be handled and how the `detail` field should be interpreted:
	//   * `HTTP_ERROR` - The error should be handled based on the HTTP status code (`status`) of the response according to RFC-9910, and `detail` should be interpreted as a human-readable string.
	//   * `CONCURRENT_UPDATE` - A concurrent update caused the `PUT` or `PATCH` request to fail. A `PUT` request can be retried after using `GET` to obtain the latest resource version and applying the desired change to it. A `PATCH` request can be retried without any changes to the request content.
	//   * `UNKNOWN_REQUEST` - The client request is unroutable due to an unknown content-type, method, or resource path. This can be indicate a versioning issue between the client and server.
	Code *ErrorContentCode `json:"code,omitempty"`

	// Status HTTP status code and reason
	Status *string `json:"status,omitempty"`

	// Detail Detail about the error
	Detail *string `json:"detail,omitempty"`
}

// ErrorContentCode Application-level error code that describes how the error should be handled and how the `detail` field should be interpreted:
//   - `HTTP_ERROR` - The error should be handled based on the HTTP status code (`status`) of the response according to RFC-9910, and `detail` should be interpreted as a human-readable string.
//   - `CONCURRENT_UPDATE` - A concurrent update caused the `PUT` or `PATCH` request to fail. A `PUT` request can be retried after using `GET` to obtain the latest resource version and applying the desired change to it. A `PATCH` request can be retried without any changes to the request content.
//   - `UNKNOWN_REQUEST` - The client request is unroutable due to an unknown content-type, method, or resource path. This can be indicate a versioning issue between the client and server.
type ErrorContentCode string

// ExpandedListEntry defines model for ExpandedListEntry.
type ExpandedListEntry struct {
	// Ref The sub-path relative to the request URL that can be used to obtain the resource
	Ref *string `json:"$ref,omitempty"`
}

// ImportSourceModel defines model for ImportSourceModel.
type ImportSourceModel struct {
	// BackupHandle The existing backup handle to import
	BackupHandle string `cty:"backup_handle" hcl:"backup_handle" json:"backupHandle" tfsdk:"backup_handle"`

	// BackupPlugin The plugin used to create the backup to import
	BackupPlugin string `cty:"backup_plugin" hcl:"backup_plugin" json:"backupPlugin" tfsdk:"backup_plugin"`
}

// ItemList defines model for ItemList.
type ItemList struct {
	// Offset The offset at which items are being listed, based on the user request
	Offset *int32 `json:"offset,omitempty"`

	// Cursor The cursor at which items are being listed, based on the user request
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of items that could have been returned, based on the user request. If `limit` is equal to the number of items returned, then it is possible that more items are available (see `next`), which can be obtained by advancing the `offset` by `limit` or supplying the last value in the list (or its `$ref`) as `cursor`.
	Limit *int32 `json:"limit,omitempty"`

	// Items The list of items returned. If expansion of payload fields was requested using the query parameter `expand` or `expand.<field>`, then the items will be objects, otherwise, they will be strings representing the sub-paths at which the resource can be found.
	Items *[]ItemList_Items_Item `json:"items,omitempty"`

	// Next The URL to obtain the next list of items, if `limit` was specified and more items are available. The absence of the `next` field indicates that all items have been returned.
	Next *string `json:"next,omitempty"`

	// Total The total number of items available.
	Total *int32 `json:"total,omitempty"`
}

// ItemListItems0 defines model for .
type ItemListItems0 = string

// ItemList_Items_Item defines model for ItemList.items.Item.
type ItemList_Items_Item struct {
	union json.RawMessage
}

// JsonNode defines model for JsonNode.
type JsonNode struct {
	union json.RawMessage
}

// JsonNode0 defines model for .
type JsonNode0 = map[string]interface{}

// JsonNode1 defines model for .
type JsonNode1 = string

// JsonNode2 defines model for .
type JsonNode2 = float32

// JsonNode3 defines model for .
type JsonNode3 = bool

// JsonPatchOperation defines model for JsonPatchOperation.
type JsonPatchOperation struct {
	Op    JsonPatchOperationOp `json:"op"`
	From  *string              `json:"from,omitempty"`
	Path  string               `json:"path"`
	Value *JsonNode            `json:"value,omitempty"`
}

// JsonPatchOperationOp defines model for JsonPatchOperation.Op.
type JsonPatchOperationOp string

// MaintenanceModel defines model for MaintenanceModel.
type MaintenanceModel struct {
	// ExpiresAtTime The time at which the project or database will be disabled
	ExpiresAtTime *time.Time `json:"expiresAtTime,omitempty" tfsdk:"-"`

	// ExpiresIn The time until the project or database is disabled, e.g. `1d`
	ExpiresIn *string `json:"expiresIn,omitempty" tfsdk:"-"`

	// IsDisabled Whether the project or database should be shutdown
	IsDisabled *bool `cty:"is_disabled" hcl:"is_disabled" json:"isDisabled,omitempty" tfsdk:"is_disabled"`
}

// ProjectModel defines model for ProjectModel.
type ProjectModel struct {
	// Organization The organization that the project belongs to
	Organization string `cty:"organization" hcl:"organization" json:"organization" tfsdk:"organization"`

	// Name The name of the project
	Name string `cty:"name" hcl:"name" json:"name" tfsdk:"name"`

	// Labels User-defined labels attached to the resource that can be used for filtering
	Labels *map[string]string `cty:"labels" hcl:"labels" json:"labels,omitempty" tfsdk:"labels"`

	// Sla The SLA for the project. Cannot be updated once the project is created.
	Sla string `cty:"sla" hcl:"sla" json:"sla" tfsdk:"sla"`

	// Tier The service tier for the project
	Tier string `cty:"tier" hcl:"tier" json:"tier" tfsdk:"tier"`

	// ResourceVersion The version of the resource. When specified in a `PUT` request payload, indicates that the resoure should be updated, and is used by the system to guard against concurrent updates.
	ResourceVersion *string                 `json:"resourceVersion,omitempty" tfsdk:"-"`
	Maintenance     *MaintenanceModel       `cty:"maintenance" hcl:"maintenance" json:"maintenance,omitempty" tfsdk:"maintenance"`
	Properties      *ProjectPropertiesModel `cty:"properties" hcl:"properties" json:"properties,omitempty" tfsdk:"properties"`
	Status          *ProjectStatusModel     `cty:"status" hcl:"status" json:"status,omitempty" tfsdk:"status"`
}

// ProjectPropertiesModel defines model for ProjectPropertiesModel.
type ProjectPropertiesModel struct {
	// TierParameters Opaque parameters supplied to project service tier.
	TierParameters *map[string]string `cty:"tier_parameters" hcl:"tier_parameters" json:"tierParameters,omitempty" tfsdk:"tier_parameters"`

	// ProductVersion The version/tag of the NuoDB image to use. For available tags, see https://hub.docker.com/r/nuodb/nuodb/tags. If omitted, the project version will be resolved based on the SLA and cluster configuration.
	ProductVersion *string `cty:"product_version" hcl:"product_version" json:"productVersion,omitempty" tfsdk:"product_version"`
}

// ProjectStatusModel defines model for ProjectStatusModel.
type ProjectStatusModel struct {
	// CaPem The PEM-encoded certificate for SQL clients to verify database servers within the project
	CaPem *string `cty:"ca_pem" hcl:"ca_pem" json:"caPem,omitempty" tfsdk:"ca_pem"`

	// Ready Whether the project is ready
	Ready *bool `cty:"ready" hcl:"ready" json:"ready,omitempty" tfsdk:"ready"`

	// Shutdown Whether the project and all of its databases have shutdown
	Shutdown *bool `cty:"shutdown" hcl:"shutdown" json:"shutdown,omitempty" tfsdk:"shutdown"`

	// Message Message summarizing the state of the project
	Message *string `cty:"message" hcl:"message" json:"message,omitempty" tfsdk:"message"`

	// State The state of the project:
	//   * `Available` - The project is available
	//   * `Creating` - The project is being created and not yet available
	//   * `Modifying` - The project is being modified
	//   * `Stopping` - Shutdown is in progress for this project
	//   * `Stopped` - The project and its databases have been stopped
	//   * `Expired` - The project and its databases have expired
	//   * `Failed` - The project has failed to achieve a usable state
	//   * `Deleting` - The project has been marked for deletion, which is in progress
	//   * `RotatingCertificates` - TLS certificates rotation is in progress for this domain
	State *ProjectStatusModelState `cty:"state" hcl:"state" json:"state,omitempty" tfsdk:"state"`
}

// ProjectStatusModelState The state of the project:
//   - `Available` - The project is available
//   - `Creating` - The project is being created and not yet available
//   - `Modifying` - The project is being modified
//   - `Stopping` - Shutdown is in progress for this project
//   - `Stopped` - The project and its databases have been stopped
//   - `Expired` - The project and its databases have expired
//   - `Failed` - The project has failed to achieve a usable state
//   - `Deleting` - The project has been marked for deletion, which is in progress
//   - `RotatingCertificates` - TLS certificates rotation is in progress for this domain
type ProjectStatusModelState string

// RestoreFromModel defines model for RestoreFromModel.
type RestoreFromModel struct {
	// Backup The name of the backup to restore the database from. If a fully-qualified name is not supplied, then the organization, project, or name of the database being created is assumed.
	Backup *string `cty:"backup" hcl:"backup" json:"backup,omitempty" tfsdk:"backup"`
}

// RetentionModel defines model for RetentionModel.
type RetentionModel struct {
	// Hourly The number of hourly backups to retain
	Hourly *int32 `cty:"hourly" hcl:"hourly" json:"hourly,omitempty" tfsdk:"hourly"`

	// Daily The number of daily backups to retain
	Daily *int32 `cty:"daily" hcl:"daily" json:"daily,omitempty" tfsdk:"daily"`

	// Weekly The number of weekly backups to retain
	Weekly *int32 `cty:"weekly" hcl:"weekly" json:"weekly,omitempty" tfsdk:"weekly"`

	// Monthly The number of monthly backups to retain
	Monthly *int32 `cty:"monthly" hcl:"monthly" json:"monthly,omitempty" tfsdk:"monthly"`

	// Yearly The number of yearly backups to retain
	Yearly   *int32                 `cty:"yearly" hcl:"yearly" json:"yearly,omitempty" tfsdk:"yearly"`
	Settings *RotationSettingsModel `cty:"settings" hcl:"settings" json:"settings,omitempty" tfsdk:"settings"`
}

// RotationSettingsModel defines model for RotationSettingsModel.
type RotationSettingsModel struct {
	// DayOfWeek The day of the week used to promote backup to weekly
	DayOfWeek *RotationSettingsModelDayOfWeek `cty:"day_of_week" hcl:"day_of_week" json:"dayOfWeek,omitempty" tfsdk:"day_of_week"`

	// Month The month of the year used to promote backup to yearly
	Month *RotationSettingsModelMonth `cty:"month" hcl:"month" json:"month,omitempty" tfsdk:"month"`

	// RelativeToLast Whether to apply the backup rotation scheme relative to the last successful backup instead to the current time
	RelativeToLast *bool `cty:"relative_to_last" hcl:"relative_to_last" json:"relativeToLast,omitempty" tfsdk:"relative_to_last"`

	// PromoteLatestToHourly Whether to promote the latest backup within the hour if multiple backups exist for that hour
	PromoteLatestToHourly *bool `cty:"promote_latest_to_hourly" hcl:"promote_latest_to_hourly" json:"promoteLatestToHourly,omitempty" tfsdk:"promote_latest_to_hourly"`

	// PromoteLatestToDaily Whether to promote the latest backup within the day if multiple backups exist for that day
	PromoteLatestToDaily *bool `cty:"promote_latest_to_daily" hcl:"promote_latest_to_daily" json:"promoteLatestToDaily,omitempty" tfsdk:"promote_latest_to_daily"`

	// PromoteLatestToMonthly Whether to promote the latest backup within the month if multiple backups exist for that month
	PromoteLatestToMonthly *bool `cty:"promote_latest_to_monthly" hcl:"promote_latest_to_monthly" json:"promoteLatestToMonthly,omitempty" tfsdk:"promote_latest_to_monthly"`
}

// RotationSettingsModelDayOfWeek The day of the week used to promote backup to weekly
type RotationSettingsModelDayOfWeek string

// RotationSettingsModelMonth The month of the year used to promote backup to yearly
type RotationSettingsModelMonth string

// SelectorModel defines model for SelectorModel.
type SelectorModel struct {
	// Scope The scope that the backup policy applies to
	Scope string `cty:"scope" hcl:"scope" json:"scope" tfsdk:"scope"`

	// Slas The SLAs to filter databases on
	Slas *[]string `cty:"slas" hcl:"slas" json:"slas,omitempty" tfsdk:"slas"`

	// Tiers The tiers to filter databases on
	Tiers *[]string `cty:"tiers" hcl:"tiers" json:"tiers,omitempty" tfsdk:"tiers"`

	// Labels The user-defined labels to filter databases on
	Labels *map[string]string `cty:"labels" hcl:"labels" json:"labels,omitempty" tfsdk:"labels"`
}

// UpdateDbaPasswordModel defines model for UpdateDbaPasswordModel.
type UpdateDbaPasswordModel struct {
	// Current The current DBA password, which must be supplied for verification purposes
	Current string `json:"current"`

	// Target The target DBA password
	Target *string `json:"target,omitempty"`

	// Resync Whether to update configured DBA password so that it matches actual DBA password. If `true`, `current` is verified by connecting to the database directly before updating configured DBA password.
	Resync *bool `json:"resync,omitempty"`
}

// GetAllBackupPoliciesParams defines parameters for GetAllBackupPolicies.
type GetAllBackupPoliciesParams struct {
	// Offset The offset at which to list items
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Cursor The cursor at which to list items, which represents the last item returned. If specified, all items returned must be lexicographically greater than the supplied value. For expanded payloads, the `$ref` value is compared to the cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return. If payload expansion was enabled and `limit` was not specified, the default of 20 is used. Otherwise, the default is 0 to indicate that all items should be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Whether to expand payload fields. If `expand=true`, then all payload fields are expanded. If `expand=<field>,...` is supplied, then the value is interpreted as a comma-separated list of top-level fields to expand. If `expand.<field>=<JSONPath expression>` is supplied, then the JSONPath expression is used to resolve the user-supplied field.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// LabelFilter Comma-separated list of filters to apply based on labels, which are composed using `AND`. Acceptable filter expressions are:
	// * `key` - Only return resources that have label with specified key
	// * `key=value` - Only return resources that have label with specified key set to value
	// * `!key` - Only return resources that do _not_ have label with specified key
	// * `key!=value` - Only return resources that do _not_ have label with specified key set to value
	LabelFilter *string `form:"labelFilter,omitempty" json:"labelFilter,omitempty"`

	// FieldFilter Comma-separated list of filters to apply based on fields, which are composed using `AND`. Acceptable filter expressions are:
	// * `fieldPath` - Only return resources that have a non-`null` value at the specified field path
	// * `fieldPath=value` - Only return resources that have a matching value at the specified field path
	// * `!fieldPath` - Only return resources that do have a `null` value at the specified field path
	// * `fieldPath!=value` - Only return resources that do _not_ have a matching value at the specified field path
	FieldFilter *string `form:"fieldFilter,omitempty" json:"fieldFilter,omitempty"`

	// ListAccessible Whether to return any accessible sub-resources even if the current user does not have access privileges to list all resources at this level
	ListAccessible *bool `form:"listAccessible,omitempty" json:"listAccessible,omitempty"`
}

// GetBackupPoliciesParams defines parameters for GetBackupPolicies.
type GetBackupPoliciesParams struct {
	// Offset The offset at which to list items
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Cursor The cursor at which to list items, which represents the last item returned. If specified, all items returned must be lexicographically greater than the supplied value. For expanded payloads, the `$ref` value is compared to the cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return. If payload expansion was enabled and `limit` was not specified, the default of 20 is used. Otherwise, the default is 0 to indicate that all items should be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Whether to expand payload fields. If `expand=true`, then all payload fields are expanded. If `expand=<field>,...` is supplied, then the value is interpreted as a comma-separated list of top-level fields to expand. If `expand.<field>=<JSONPath expression>` is supplied, then the JSONPath expression is used to resolve the user-supplied field.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// LabelFilter Comma-separated list of filters to apply based on labels, which are composed using `AND`. Acceptable filter expressions are:
	// * `key` - Only return resources that have label with specified key
	// * `key=value` - Only return resources that have label with specified key set to value
	// * `!key` - Only return resources that do _not_ have label with specified key
	// * `key!=value` - Only return resources that do _not_ have label with specified key set to value
	LabelFilter *string `form:"labelFilter,omitempty" json:"labelFilter,omitempty"`

	// FieldFilter Comma-separated list of filters to apply based on fields, which are composed using `AND`. Acceptable filter expressions are:
	// * `fieldPath` - Only return resources that have a non-`null` value at the specified field path
	// * `fieldPath=value` - Only return resources that have a matching value at the specified field path
	// * `!fieldPath` - Only return resources that do have a `null` value at the specified field path
	// * `fieldPath!=value` - Only return resources that do _not_ have a matching value at the specified field path
	FieldFilter *string `form:"fieldFilter,omitempty" json:"fieldFilter,omitempty"`

	// ListAccessible Whether to return any accessible sub-resources even if the current user does not have access privileges to list all resources at this level
	ListAccessible *bool `form:"listAccessible,omitempty" json:"listAccessible,omitempty"`
}

// DeleteBackupPolicyParams defines parameters for DeleteBackupPolicy.
type DeleteBackupPolicyParams struct {
	// TimeoutSeconds The number of seconds to wait for the operation to be finalized, unless 0 is specified which indicates not to wait
	TimeoutSeconds *int32 `form:"timeoutSeconds,omitempty" json:"timeoutSeconds,omitempty"`
}

// PatchBackupPolicyApplicationJSONPatchPlusJSONBody defines parameters for PatchBackupPolicy.
type PatchBackupPolicyApplicationJSONPatchPlusJSONBody = []JsonPatchOperation

// GetBackupsFromPolicyParams defines parameters for GetBackupsFromPolicy.
type GetBackupsFromPolicyParams struct {
	// Offset The offset at which to list items
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Cursor The cursor at which to list items, which represents the last item returned. If specified, all items returned must be lexicographically greater than the supplied value. For expanded payloads, the `$ref` value is compared to the cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return. If payload expansion was enabled and `limit` was not specified, the default of 20 is used. Otherwise, the default is 0 to indicate that all items should be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Whether to expand payload fields. If `expand=true`, then all payload fields are expanded. If `expand=<field>,...` is supplied, then the value is interpreted as a comma-separated list of top-level fields to expand. If `expand.<field>=<JSONPath expression>` is supplied, then the JSONPath expression is used to resolve the user-supplied field.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// LabelFilter Comma-separated list of filters to apply based on labels, which are composed using `AND`. Acceptable filter expressions are:
	// * `key` - Only return resources that have label with specified key
	// * `key=value` - Only return resources that have label with specified key set to value
	// * `!key` - Only return resources that do _not_ have label with specified key
	// * `key!=value` - Only return resources that do _not_ have label with specified key set to value
	LabelFilter *string `form:"labelFilter,omitempty" json:"labelFilter,omitempty"`

	// FieldFilter Comma-separated list of filters to apply based on fields, which are composed using `AND`. Acceptable filter expressions are:
	// * `fieldPath` - Only return resources that have a non-`null` value at the specified field path
	// * `fieldPath=value` - Only return resources that have a matching value at the specified field path
	// * `!fieldPath` - Only return resources that do have a `null` value at the specified field path
	// * `fieldPath!=value` - Only return resources that do _not_ have a matching value at the specified field path
	FieldFilter *string `form:"fieldFilter,omitempty" json:"fieldFilter,omitempty"`

	// ListAccessible Whether to return any accessible sub-resources even if the current user does not have access privileges to list all resources at this level
	ListAccessible *bool `form:"listAccessible,omitempty" json:"listAccessible,omitempty"`
}

// GetMatchingDatabasesParams defines parameters for GetMatchingDatabases.
type GetMatchingDatabasesParams struct {
	// Offset The offset at which to list items
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Cursor The cursor at which to list items, which represents the last item returned. If specified, all items returned must be lexicographically greater than the supplied value. For expanded payloads, the `$ref` value is compared to the cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return. If payload expansion was enabled and `limit` was not specified, the default of 20 is used. Otherwise, the default is 0 to indicate that all items should be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Whether to expand payload fields. If `expand=true`, then all payload fields are expanded. If `expand=<field>,...` is supplied, then the value is interpreted as a comma-separated list of top-level fields to expand. If `expand.<field>=<JSONPath expression>` is supplied, then the JSONPath expression is used to resolve the user-supplied field.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// LabelFilter Comma-separated list of filters to apply based on labels, which are composed using `AND`. Acceptable filter expressions are:
	// * `key` - Only return resources that have label with specified key
	// * `key=value` - Only return resources that have label with specified key set to value
	// * `!key` - Only return resources that do _not_ have label with specified key
	// * `key!=value` - Only return resources that do _not_ have label with specified key set to value
	LabelFilter *string `form:"labelFilter,omitempty" json:"labelFilter,omitempty"`

	// FieldFilter Comma-separated list of filters to apply based on fields, which are composed using `AND`. Acceptable filter expressions are:
	// * `fieldPath` - Only return resources that have a non-`null` value at the specified field path
	// * `fieldPath=value` - Only return resources that have a matching value at the specified field path
	// * `!fieldPath` - Only return resources that do have a `null` value at the specified field path
	// * `fieldPath!=value` - Only return resources that do _not_ have a matching value at the specified field path
	FieldFilter *string `form:"fieldFilter,omitempty" json:"fieldFilter,omitempty"`

	// ListAccessible Whether to return any accessible sub-resources even if the current user does not have access privileges to list all resources at this level
	ListAccessible *bool `form:"listAccessible,omitempty" json:"listAccessible,omitempty"`
}

// GetAllBackupsParams defines parameters for GetAllBackups.
type GetAllBackupsParams struct {
	// Offset The offset at which to list items
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Cursor The cursor at which to list items, which represents the last item returned. If specified, all items returned must be lexicographically greater than the supplied value. For expanded payloads, the `$ref` value is compared to the cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return. If payload expansion was enabled and `limit` was not specified, the default of 20 is used. Otherwise, the default is 0 to indicate that all items should be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Whether to expand payload fields. If `expand=true`, then all payload fields are expanded. If `expand=<field>,...` is supplied, then the value is interpreted as a comma-separated list of top-level fields to expand. If `expand.<field>=<JSONPath expression>` is supplied, then the JSONPath expression is used to resolve the user-supplied field.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// LabelFilter Comma-separated list of filters to apply based on labels, which are composed using `AND`. Acceptable filter expressions are:
	// * `key` - Only return resources that have label with specified key
	// * `key=value` - Only return resources that have label with specified key set to value
	// * `!key` - Only return resources that do _not_ have label with specified key
	// * `key!=value` - Only return resources that do _not_ have label with specified key set to value
	LabelFilter *string `form:"labelFilter,omitempty" json:"labelFilter,omitempty"`

	// FieldFilter Comma-separated list of filters to apply based on fields, which are composed using `AND`. Acceptable filter expressions are:
	// * `fieldPath` - Only return resources that have a non-`null` value at the specified field path
	// * `fieldPath=value` - Only return resources that have a matching value at the specified field path
	// * `!fieldPath` - Only return resources that do have a `null` value at the specified field path
	// * `fieldPath!=value` - Only return resources that do _not_ have a matching value at the specified field path
	FieldFilter *string `form:"fieldFilter,omitempty" json:"fieldFilter,omitempty"`

	// ListAccessible Whether to return any accessible sub-resources even if the current user does not have access privileges to list all resources at this level
	ListAccessible *bool `form:"listAccessible,omitempty" json:"listAccessible,omitempty"`
}

// GetOrganizationBackupsParams defines parameters for GetOrganizationBackups.
type GetOrganizationBackupsParams struct {
	// Offset The offset at which to list items
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Cursor The cursor at which to list items, which represents the last item returned. If specified, all items returned must be lexicographically greater than the supplied value. For expanded payloads, the `$ref` value is compared to the cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return. If payload expansion was enabled and `limit` was not specified, the default of 20 is used. Otherwise, the default is 0 to indicate that all items should be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Whether to expand payload fields. If `expand=true`, then all payload fields are expanded. If `expand=<field>,...` is supplied, then the value is interpreted as a comma-separated list of top-level fields to expand. If `expand.<field>=<JSONPath expression>` is supplied, then the JSONPath expression is used to resolve the user-supplied field.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// LabelFilter Comma-separated list of filters to apply based on labels, which are composed using `AND`. Acceptable filter expressions are:
	// * `key` - Only return resources that have label with specified key
	// * `key=value` - Only return resources that have label with specified key set to value
	// * `!key` - Only return resources that do _not_ have label with specified key
	// * `key!=value` - Only return resources that do _not_ have label with specified key set to value
	LabelFilter *string `form:"labelFilter,omitempty" json:"labelFilter,omitempty"`

	// FieldFilter Comma-separated list of filters to apply based on fields, which are composed using `AND`. Acceptable filter expressions are:
	// * `fieldPath` - Only return resources that have a non-`null` value at the specified field path
	// * `fieldPath=value` - Only return resources that have a matching value at the specified field path
	// * `!fieldPath` - Only return resources that do have a `null` value at the specified field path
	// * `fieldPath!=value` - Only return resources that do _not_ have a matching value at the specified field path
	FieldFilter *string `form:"fieldFilter,omitempty" json:"fieldFilter,omitempty"`

	// ListAccessible Whether to return any accessible sub-resources even if the current user does not have access privileges to list all resources at this level
	ListAccessible *bool `form:"listAccessible,omitempty" json:"listAccessible,omitempty"`
}

// GetProjectBackupsParams defines parameters for GetProjectBackups.
type GetProjectBackupsParams struct {
	// Offset The offset at which to list items
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Cursor The cursor at which to list items, which represents the last item returned. If specified, all items returned must be lexicographically greater than the supplied value. For expanded payloads, the `$ref` value is compared to the cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return. If payload expansion was enabled and `limit` was not specified, the default of 20 is used. Otherwise, the default is 0 to indicate that all items should be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Whether to expand payload fields. If `expand=true`, then all payload fields are expanded. If `expand=<field>,...` is supplied, then the value is interpreted as a comma-separated list of top-level fields to expand. If `expand.<field>=<JSONPath expression>` is supplied, then the JSONPath expression is used to resolve the user-supplied field.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// LabelFilter Comma-separated list of filters to apply based on labels, which are composed using `AND`. Acceptable filter expressions are:
	// * `key` - Only return resources that have label with specified key
	// * `key=value` - Only return resources that have label with specified key set to value
	// * `!key` - Only return resources that do _not_ have label with specified key
	// * `key!=value` - Only return resources that do _not_ have label with specified key set to value
	LabelFilter *string `form:"labelFilter,omitempty" json:"labelFilter,omitempty"`

	// FieldFilter Comma-separated list of filters to apply based on fields, which are composed using `AND`. Acceptable filter expressions are:
	// * `fieldPath` - Only return resources that have a non-`null` value at the specified field path
	// * `fieldPath=value` - Only return resources that have a matching value at the specified field path
	// * `!fieldPath` - Only return resources that do have a `null` value at the specified field path
	// * `fieldPath!=value` - Only return resources that do _not_ have a matching value at the specified field path
	FieldFilter *string `form:"fieldFilter,omitempty" json:"fieldFilter,omitempty"`

	// ListAccessible Whether to return any accessible sub-resources even if the current user does not have access privileges to list all resources at this level
	ListAccessible *bool `form:"listAccessible,omitempty" json:"listAccessible,omitempty"`
}

// GetBackupsParams defines parameters for GetBackups.
type GetBackupsParams struct {
	// Offset The offset at which to list items
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Cursor The cursor at which to list items, which represents the last item returned. If specified, all items returned must be lexicographically greater than the supplied value. For expanded payloads, the `$ref` value is compared to the cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return. If payload expansion was enabled and `limit` was not specified, the default of 20 is used. Otherwise, the default is 0 to indicate that all items should be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Whether to expand payload fields. If `expand=true`, then all payload fields are expanded. If `expand=<field>,...` is supplied, then the value is interpreted as a comma-separated list of top-level fields to expand. If `expand.<field>=<JSONPath expression>` is supplied, then the JSONPath expression is used to resolve the user-supplied field.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// LabelFilter Comma-separated list of filters to apply based on labels, which are composed using `AND`. Acceptable filter expressions are:
	// * `key` - Only return resources that have label with specified key
	// * `key=value` - Only return resources that have label with specified key set to value
	// * `!key` - Only return resources that do _not_ have label with specified key
	// * `key!=value` - Only return resources that do _not_ have label with specified key set to value
	LabelFilter *string `form:"labelFilter,omitempty" json:"labelFilter,omitempty"`

	// FieldFilter Comma-separated list of filters to apply based on fields, which are composed using `AND`. Acceptable filter expressions are:
	// * `fieldPath` - Only return resources that have a non-`null` value at the specified field path
	// * `fieldPath=value` - Only return resources that have a matching value at the specified field path
	// * `!fieldPath` - Only return resources that do have a `null` value at the specified field path
	// * `fieldPath!=value` - Only return resources that do _not_ have a matching value at the specified field path
	FieldFilter *string `form:"fieldFilter,omitempty" json:"fieldFilter,omitempty"`

	// ListAccessible Whether to return any accessible sub-resources even if the current user does not have access privileges to list all resources at this level
	ListAccessible *bool `form:"listAccessible,omitempty" json:"listAccessible,omitempty"`
}

// DeleteBackupParams defines parameters for DeleteBackup.
type DeleteBackupParams struct {
	// TimeoutSeconds The number of seconds to wait for the operation to be finalized, unless 0 is specified which indicates not to wait
	TimeoutSeconds *int32 `form:"timeoutSeconds,omitempty" json:"timeoutSeconds,omitempty"`
}

// PatchBackupApplicationJSONPatchPlusJSONBody defines parameters for PatchBackup.
type PatchBackupApplicationJSONPatchPlusJSONBody = []JsonPatchOperation

// GetAllDatabasesParams defines parameters for GetAllDatabases.
type GetAllDatabasesParams struct {
	// Offset The offset at which to list items
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Cursor The cursor at which to list items, which represents the last item returned. If specified, all items returned must be lexicographically greater than the supplied value. For expanded payloads, the `$ref` value is compared to the cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return. If payload expansion was enabled and `limit` was not specified, the default of 20 is used. Otherwise, the default is 0 to indicate that all items should be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Whether to expand payload fields. If `expand=true`, then all payload fields are expanded. If `expand=<field>,...` is supplied, then the value is interpreted as a comma-separated list of top-level fields to expand. If `expand.<field>=<JSONPath expression>` is supplied, then the JSONPath expression is used to resolve the user-supplied field.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// LabelFilter Comma-separated list of filters to apply based on labels, which are composed using `AND`. Acceptable filter expressions are:
	// * `key` - Only return resources that have label with specified key
	// * `key=value` - Only return resources that have label with specified key set to value
	// * `!key` - Only return resources that do _not_ have label with specified key
	// * `key!=value` - Only return resources that do _not_ have label with specified key set to value
	LabelFilter *string `form:"labelFilter,omitempty" json:"labelFilter,omitempty"`

	// FieldFilter Comma-separated list of filters to apply based on fields, which are composed using `AND`. Acceptable filter expressions are:
	// * `fieldPath` - Only return resources that have a non-`null` value at the specified field path
	// * `fieldPath=value` - Only return resources that have a matching value at the specified field path
	// * `!fieldPath` - Only return resources that do have a `null` value at the specified field path
	// * `fieldPath!=value` - Only return resources that do _not_ have a matching value at the specified field path
	FieldFilter *string `form:"fieldFilter,omitempty" json:"fieldFilter,omitempty"`

	// ListAccessible Whether to return any accessible sub-resources even if the current user does not have access privileges to list all resources at this level
	ListAccessible *bool `form:"listAccessible,omitempty" json:"listAccessible,omitempty"`
}

// GetOrganizationDatabasesParams defines parameters for GetOrganizationDatabases.
type GetOrganizationDatabasesParams struct {
	// Offset The offset at which to list items
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Cursor The cursor at which to list items, which represents the last item returned. If specified, all items returned must be lexicographically greater than the supplied value. For expanded payloads, the `$ref` value is compared to the cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return. If payload expansion was enabled and `limit` was not specified, the default of 20 is used. Otherwise, the default is 0 to indicate that all items should be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Whether to expand payload fields. If `expand=true`, then all payload fields are expanded. If `expand=<field>,...` is supplied, then the value is interpreted as a comma-separated list of top-level fields to expand. If `expand.<field>=<JSONPath expression>` is supplied, then the JSONPath expression is used to resolve the user-supplied field.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// LabelFilter Comma-separated list of filters to apply based on labels, which are composed using `AND`. Acceptable filter expressions are:
	// * `key` - Only return resources that have label with specified key
	// * `key=value` - Only return resources that have label with specified key set to value
	// * `!key` - Only return resources that do _not_ have label with specified key
	// * `key!=value` - Only return resources that do _not_ have label with specified key set to value
	LabelFilter *string `form:"labelFilter,omitempty" json:"labelFilter,omitempty"`

	// FieldFilter Comma-separated list of filters to apply based on fields, which are composed using `AND`. Acceptable filter expressions are:
	// * `fieldPath` - Only return resources that have a non-`null` value at the specified field path
	// * `fieldPath=value` - Only return resources that have a matching value at the specified field path
	// * `!fieldPath` - Only return resources that do have a `null` value at the specified field path
	// * `fieldPath!=value` - Only return resources that do _not_ have a matching value at the specified field path
	FieldFilter *string `form:"fieldFilter,omitempty" json:"fieldFilter,omitempty"`

	// ListAccessible Whether to return any accessible sub-resources even if the current user does not have access privileges to list all resources at this level
	ListAccessible *bool `form:"listAccessible,omitempty" json:"listAccessible,omitempty"`
}

// GetDatabasesParams defines parameters for GetDatabases.
type GetDatabasesParams struct {
	// Offset The offset at which to list items
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Cursor The cursor at which to list items, which represents the last item returned. If specified, all items returned must be lexicographically greater than the supplied value. For expanded payloads, the `$ref` value is compared to the cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return. If payload expansion was enabled and `limit` was not specified, the default of 20 is used. Otherwise, the default is 0 to indicate that all items should be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Whether to expand payload fields. If `expand=true`, then all payload fields are expanded. If `expand=<field>,...` is supplied, then the value is interpreted as a comma-separated list of top-level fields to expand. If `expand.<field>=<JSONPath expression>` is supplied, then the JSONPath expression is used to resolve the user-supplied field.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// LabelFilter Comma-separated list of filters to apply based on labels, which are composed using `AND`. Acceptable filter expressions are:
	// * `key` - Only return resources that have label with specified key
	// * `key=value` - Only return resources that have label with specified key set to value
	// * `!key` - Only return resources that do _not_ have label with specified key
	// * `key!=value` - Only return resources that do _not_ have label with specified key set to value
	LabelFilter *string `form:"labelFilter,omitempty" json:"labelFilter,omitempty"`

	// FieldFilter Comma-separated list of filters to apply based on fields, which are composed using `AND`. Acceptable filter expressions are:
	// * `fieldPath` - Only return resources that have a non-`null` value at the specified field path
	// * `fieldPath=value` - Only return resources that have a matching value at the specified field path
	// * `!fieldPath` - Only return resources that do have a `null` value at the specified field path
	// * `fieldPath!=value` - Only return resources that do _not_ have a matching value at the specified field path
	FieldFilter *string `form:"fieldFilter,omitempty" json:"fieldFilter,omitempty"`

	// ListAccessible Whether to return any accessible sub-resources even if the current user does not have access privileges to list all resources at this level
	ListAccessible *bool `form:"listAccessible,omitempty" json:"listAccessible,omitempty"`
}

// DeleteDatabaseParams defines parameters for DeleteDatabase.
type DeleteDatabaseParams struct {
	// TimeoutSeconds The number of seconds to wait for the operation to be finalized, unless 0 is specified which indicates not to wait
	TimeoutSeconds *int32 `form:"timeoutSeconds,omitempty" json:"timeoutSeconds,omitempty"`
}

// PatchDatabaseApplicationJSONPatchPlusJSONBody defines parameters for PatchDatabase.
type PatchDatabaseApplicationJSONPatchPlusJSONBody = []JsonPatchOperation

// UpdateDbaPasswordParams defines parameters for UpdateDbaPassword.
type UpdateDbaPasswordParams struct {
	// TimeoutSeconds The number of seconds to wait for the operation to be finalized, unless 0 is specified which indicates not to wait
	TimeoutSeconds *int32 `form:"timeoutSeconds,omitempty" json:"timeoutSeconds,omitempty"`
}

// GetAllProjectsParams defines parameters for GetAllProjects.
type GetAllProjectsParams struct {
	// Offset The offset at which to list items
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Cursor The cursor at which to list items, which represents the last item returned. If specified, all items returned must be lexicographically greater than the supplied value. For expanded payloads, the `$ref` value is compared to the cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return. If payload expansion was enabled and `limit` was not specified, the default of 20 is used. Otherwise, the default is 0 to indicate that all items should be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Whether to expand payload fields. If `expand=true`, then all payload fields are expanded. If `expand=<field>,...` is supplied, then the value is interpreted as a comma-separated list of top-level fields to expand. If `expand.<field>=<JSONPath expression>` is supplied, then the JSONPath expression is used to resolve the user-supplied field.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// LabelFilter Comma-separated list of filters to apply based on labels, which are composed using `AND`. Acceptable filter expressions are:
	// * `key` - Only return resources that have label with specified key
	// * `key=value` - Only return resources that have label with specified key set to value
	// * `!key` - Only return resources that do _not_ have label with specified key
	// * `key!=value` - Only return resources that do _not_ have label with specified key set to value
	LabelFilter *string `form:"labelFilter,omitempty" json:"labelFilter,omitempty"`

	// FieldFilter Comma-separated list of filters to apply based on fields, which are composed using `AND`. Acceptable filter expressions are:
	// * `fieldPath` - Only return resources that have a non-`null` value at the specified field path
	// * `fieldPath=value` - Only return resources that have a matching value at the specified field path
	// * `!fieldPath` - Only return resources that do have a `null` value at the specified field path
	// * `fieldPath!=value` - Only return resources that do _not_ have a matching value at the specified field path
	FieldFilter *string `form:"fieldFilter,omitempty" json:"fieldFilter,omitempty"`

	// ListAccessible Whether to return any accessible sub-resources even if the current user does not have access privileges to list all resources at this level
	ListAccessible *bool `form:"listAccessible,omitempty" json:"listAccessible,omitempty"`
}

// GetProjectsParams defines parameters for GetProjects.
type GetProjectsParams struct {
	// Offset The offset at which to list items
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Cursor The cursor at which to list items, which represents the last item returned. If specified, all items returned must be lexicographically greater than the supplied value. For expanded payloads, the `$ref` value is compared to the cursor.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return. If payload expansion was enabled and `limit` was not specified, the default of 20 is used. Otherwise, the default is 0 to indicate that all items should be returned.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Expand Whether to expand payload fields. If `expand=true`, then all payload fields are expanded. If `expand=<field>,...` is supplied, then the value is interpreted as a comma-separated list of top-level fields to expand. If `expand.<field>=<JSONPath expression>` is supplied, then the JSONPath expression is used to resolve the user-supplied field.
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// LabelFilter Comma-separated list of filters to apply based on labels, which are composed using `AND`. Acceptable filter expressions are:
	// * `key` - Only return resources that have label with specified key
	// * `key=value` - Only return resources that have label with specified key set to value
	// * `!key` - Only return resources that do _not_ have label with specified key
	// * `key!=value` - Only return resources that do _not_ have label with specified key set to value
	LabelFilter *string `form:"labelFilter,omitempty" json:"labelFilter,omitempty"`

	// FieldFilter Comma-separated list of filters to apply based on fields, which are composed using `AND`. Acceptable filter expressions are:
	// * `fieldPath` - Only return resources that have a non-`null` value at the specified field path
	// * `fieldPath=value` - Only return resources that have a matching value at the specified field path
	// * `!fieldPath` - Only return resources that do have a `null` value at the specified field path
	// * `fieldPath!=value` - Only return resources that do _not_ have a matching value at the specified field path
	FieldFilter *string `form:"fieldFilter,omitempty" json:"fieldFilter,omitempty"`

	// ListAccessible Whether to return any accessible sub-resources even if the current user does not have access privileges to list all resources at this level
	ListAccessible *bool `form:"listAccessible,omitempty" json:"listAccessible,omitempty"`
}

// DeleteProjectParams defines parameters for DeleteProject.
type DeleteProjectParams struct {
	// TimeoutSeconds The number of seconds to wait for the operation to be finalized, unless 0 is specified which indicates not to wait
	TimeoutSeconds *int32 `form:"timeoutSeconds,omitempty" json:"timeoutSeconds,omitempty"`
}

// PatchProjectApplicationJSONPatchPlusJSONBody defines parameters for PatchProject.
type PatchProjectApplicationJSONPatchPlusJSONBody = []JsonPatchOperation

// PatchBackupPolicyApplicationJSONPatchPlusJSONRequestBody defines body for PatchBackupPolicy for application/json-patch+json ContentType.
type PatchBackupPolicyApplicationJSONPatchPlusJSONRequestBody = PatchBackupPolicyApplicationJSONPatchPlusJSONBody

// CreateBackupPolicyJSONRequestBody defines body for CreateBackupPolicy for application/json ContentType.
type CreateBackupPolicyJSONRequestBody = BackupPolicyModel

// CreateBackupJSONRequestBody defines body for CreateBackup for application/json ContentType.
type CreateBackupJSONRequestBody = BackupCreateModel

// PatchBackupApplicationJSONPatchPlusJSONRequestBody defines body for PatchBackup for application/json-patch+json ContentType.
type PatchBackupApplicationJSONPatchPlusJSONRequestBody = PatchBackupApplicationJSONPatchPlusJSONBody

// CreateOrUpdateBackupJSONRequestBody defines body for CreateOrUpdateBackup for application/json ContentType.
type CreateOrUpdateBackupJSONRequestBody = BackupModel

// PatchDatabaseApplicationJSONPatchPlusJSONRequestBody defines body for PatchDatabase for application/json-patch+json ContentType.
type PatchDatabaseApplicationJSONPatchPlusJSONRequestBody = PatchDatabaseApplicationJSONPatchPlusJSONBody

// CreateDatabaseJSONRequestBody defines body for CreateDatabase for application/json ContentType.
type CreateDatabaseJSONRequestBody = DatabaseCreateUpdateModel

// UpdateDbaPasswordJSONRequestBody defines body for UpdateDbaPassword for application/json ContentType.
type UpdateDbaPasswordJSONRequestBody = UpdateDbaPasswordModel

// PatchProjectApplicationJSONPatchPlusJSONRequestBody defines body for PatchProject for application/json-patch+json ContentType.
type PatchProjectApplicationJSONPatchPlusJSONRequestBody = PatchProjectApplicationJSONPatchPlusJSONBody

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody = ProjectModel

// AsItemListItems0 returns the union data inside the ItemList_Items_Item as a ItemListItems0
func (t ItemList_Items_Item) AsItemListItems0() (ItemListItems0, error) {
	var body ItemListItems0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromItemListItems0 overwrites any union data inside the ItemList_Items_Item as the provided ItemListItems0
func (t *ItemList_Items_Item) FromItemListItems0(v ItemListItems0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeItemListItems0 performs a merge with any union data inside the ItemList_Items_Item, using the provided ItemListItems0
func (t *ItemList_Items_Item) MergeItemListItems0(v ItemListItems0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExpandedListEntry returns the union data inside the ItemList_Items_Item as a ExpandedListEntry
func (t ItemList_Items_Item) AsExpandedListEntry() (ExpandedListEntry, error) {
	var body ExpandedListEntry
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExpandedListEntry overwrites any union data inside the ItemList_Items_Item as the provided ExpandedListEntry
func (t *ItemList_Items_Item) FromExpandedListEntry(v ExpandedListEntry) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExpandedListEntry performs a merge with any union data inside the ItemList_Items_Item, using the provided ExpandedListEntry
func (t *ItemList_Items_Item) MergeExpandedListEntry(v ExpandedListEntry) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ItemList_Items_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ItemList_Items_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJsonNode0 returns the union data inside the JsonNode as a JsonNode0
func (t JsonNode) AsJsonNode0() (JsonNode0, error) {
	var body JsonNode0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonNode0 overwrites any union data inside the JsonNode as the provided JsonNode0
func (t *JsonNode) FromJsonNode0(v JsonNode0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonNode0 performs a merge with any union data inside the JsonNode, using the provided JsonNode0
func (t *JsonNode) MergeJsonNode0(v JsonNode0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsonNode1 returns the union data inside the JsonNode as a JsonNode1
func (t JsonNode) AsJsonNode1() (JsonNode1, error) {
	var body JsonNode1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonNode1 overwrites any union data inside the JsonNode as the provided JsonNode1
func (t *JsonNode) FromJsonNode1(v JsonNode1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonNode1 performs a merge with any union data inside the JsonNode, using the provided JsonNode1
func (t *JsonNode) MergeJsonNode1(v JsonNode1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsonNode2 returns the union data inside the JsonNode as a JsonNode2
func (t JsonNode) AsJsonNode2() (JsonNode2, error) {
	var body JsonNode2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonNode2 overwrites any union data inside the JsonNode as the provided JsonNode2
func (t *JsonNode) FromJsonNode2(v JsonNode2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonNode2 performs a merge with any union data inside the JsonNode, using the provided JsonNode2
func (t *JsonNode) MergeJsonNode2(v JsonNode2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsonNode3 returns the union data inside the JsonNode as a JsonNode3
func (t JsonNode) AsJsonNode3() (JsonNode3, error) {
	var body JsonNode3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonNode3 overwrites any union data inside the JsonNode as the provided JsonNode3
func (t *JsonNode) FromJsonNode3(v JsonNode3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonNode3 performs a merge with any union data inside the JsonNode, using the provided JsonNode3
func (t *JsonNode) MergeJsonNode3(v JsonNode3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JsonNode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JsonNode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
